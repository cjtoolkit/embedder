package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const _template = `// Code generated by Embedder. DO NOT EDIT.
// Source: {{ .Source }}

package {{ .Package }}

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"io"
	"log"
)

func {{ .Name }}() (name string, tpl []byte) {
	name = "{{ .Name }}"
	errCheck := func(err error) {
		if err != nil {
			log.Panic(err)
		}
	}

	raw, err := base64.StdEncoding.DecodeString(` + "`{{ .Tpl }}`" + `)
	errCheck(err)

	r, err := gzip.NewReader(bytes.NewReader(raw))
	errCheck(err)

	buf := &bytes.Buffer{}
	_, err = io.Copy(buf, r)
	errCheck(err)

	tpl = buf.Bytes()

	return
}
`

func main() {
	if len(os.Args) < 3 {
		return
	}

	packageName := os.Args[1]

	tpl := template.Must(template.New("tpl").Parse(_template))
	for _, match := range getMatchesFromPattern(os.Args[2:]) {
		processMatch(packageName, match, tpl)
	}
}

func checkErr(err error) {
	if err != nil {
		log.Panic(err)
	}
}

func getMatchesFromPattern(patterns []string) (matches []string) {
	for _, pattern := range patterns {
		_matches, err := filepath.Glob(pattern)
		checkErr(err)
		matches = append(matches, _matches...)
	}

	return
}

func processMatch(packageName, match string, tpl *template.Template) {
	name := strings.Split(filepath.Base(match), ".")[0]

	sourcefile, err := os.Open(match)
	checkErr(err)
	defer sourcefile.Close()

	buf := &bytes.Buffer{}
	w, err := gzip.NewWriterLevel(buf, gzip.BestCompression)
	checkErr(err)

	_, err = io.Copy(w, sourcefile)
	checkErr(err)
	w.Close()

	destFile, err := os.Create(name + ".go")
	checkErr(err)
	defer destFile.Close()

	type context struct {
		Source  string
		Package string
		Name    string
		Tpl     string
	}
	err = tpl.Execute(destFile, context{
		Source:  match,
		Package: packageName,
		Name:    name,
		Tpl:     strings.Join(split(base64.StdEncoding.EncodeToString(buf.Bytes()), 76), "\n"),
	})
}

func split(s string, size int) []string {
	ss := make([]string, 0, len(s)/size+1)
	for len(s) > 0 {
		if len(s) < size {
			size = len(s)
		}
		ss, s = append(ss, s[:size]), s[size:]

	}
	return ss
}
