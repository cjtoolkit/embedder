package main

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type templateInfo struct {
	PackageName string
	Filename    string
	Contexts    []context
}

type context struct {
	Source string
	Name   string
	tpl    string
}

func (c context) Tpl() string {
	return "`" + c.tpl + "`"
}

const _template = `// Code generated by Embedder. DO NOT EDIT.

package {{ .PackageName }}

{{ if .Contexts -}}
const (
{{- range .Contexts }}
	// Source: {{ .Source }}
	{{ .Name }} = {{ .Tpl }}
{{- end }}
)
{{- end }}
`

func main() {
	if len(os.Args) < 4 {
		log.Fatal("Args Usage: PackageName, DestFilename, GlobPattern")
	}

	info := &templateInfo{
		PackageName: os.Args[1],
		Filename:    os.Args[2],
	}

	for _, match := range getMatchesFromPattern(os.Args[3:]) {
		processMatch(info, match)
	}

	destFile, err := os.Create(info.Filename)
	checkErr(err)
	defer destFile.Close()

	template.Must(template.New("tpl").Parse(_template)).Execute(destFile, info)
}

func checkErr(err error) {
	if err != nil {
		log.Panic(err)
	}
}

func getMatchesFromPattern(patterns []string) (matches []string) {
	for _, pattern := range patterns {
		_matches, err := filepath.Glob(pattern)
		checkErr(err)
		matches = append(matches, _matches...)
	}

	return
}

func processMatch(packageName *templateInfo, match string) {
	name := strings.Title(strings.Split(filepath.Base(match), ".")[0])

	sourcefile, err := os.Open(match)
	checkErr(err)
	defer sourcefile.Close()

	buf := &bytes.Buffer{}
	w, err := gzip.NewWriterLevel(buf, gzip.BestCompression)
	checkErr(err)

	_, err = io.Copy(w, sourcefile)
	checkErr(err)
	w.Close()

	packageName.Contexts = append(packageName.Contexts, context{
		Source: strings.Replace(match, "\\", "/", -1),
		Name:   name,
		tpl:    strings.Join(split(base64.StdEncoding.EncodeToString(buf.Bytes()), 76), "\n"),
	})
}

func split(s string, size int) []string {
	ss := make([]string, 0, len(s)/size+1)
	for len(s) > 0 {
		if len(s) < size {
			size = len(s)
		}
		ss, s = append(ss, s[:size]), s[size:]

	}
	return ss
}
